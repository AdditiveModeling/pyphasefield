
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyphasefield.Engines package &#8212; pyphasefield  documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="pyphasefield-engines-package">
<h1>pyphasefield.Engines package<a class="headerlink" href="#pyphasefield-engines-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyphasefield.Engines.AnisoDorrGPU">
<span id="pyphasefield-engines-anisodorrgpu-module"></span><h2>pyphasefield.Engines.AnisoDorrGPU module<a class="headerlink" href="#module-pyphasefield.Engines.AnisoDorrGPU" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU">
<em class="property">class </em><code class="sig-prename descclassname">pyphasefield.Engines.AnisoDorrGPU.</code><code class="sig-name descname">AnisoDorrGPU</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyphasefield.html#pyphasefield.simulation.Simulation" title="pyphasefield.simulation.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyphasefield.simulation.Simulation</span></code></a></p>
<dl class="py method">
<dt id="pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU.init_fields">
<code class="sig-name descname">init_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU.init_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU.init_tdb_params">
<code class="sig-name descname">init_tdb_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU.init_tdb_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU.initialize_fields_and_imported_data">
<code class="sig-name descname">initialize_fields_and_imported_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU.initialize_fields_and_imported_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU.just_before_simulating">
<code class="sig-name descname">just_before_simulating</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU.just_before_simulating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU.simulation_loop">
<code class="sig-name descname">simulation_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.AnisoDorrGPU.AnisoDorrGPU.simulation_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.AnisoDorrGPU.engine_AnisoDorrGPU">
<code class="sig-prename descclassname">pyphasefield.Engines.AnisoDorrGPU.</code><code class="sig-name descname">engine_AnisoDorrGPU</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.AnisoDorrGPU.engine_AnisoDorrGPU" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.AnisoDorrGPU.get_thermodynamics">
<code class="sig-prename descclassname">pyphasefield.Engines.AnisoDorrGPU.</code><code class="sig-name descname">get_thermodynamics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ufunc</span></em>, <em class="sig-param"><span class="n">array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.AnisoDorrGPU.get_thermodynamics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.AnisoDorrGPU.init_AnisoDorrGPU">
<code class="sig-prename descclassname">pyphasefield.Engines.AnisoDorrGPU.</code><code class="sig-name descname">init_AnisoDorrGPU</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em>, <em class="sig-param"><span class="n">dim</span><span class="o">=</span><span class="default_value">[200, 200]</span></em>, <em class="sig-param"><span class="n">sim_type</span><span class="o">=</span><span class="default_value">'seed'</span></em>, <em class="sig-param"><span class="n">number_of_seeds</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">tdb_path</span><span class="o">=</span><span class="default_value">'Ni-Cu_Ideal.tdb'</span></em>, <em class="sig-param"><span class="n">temperature_type</span><span class="o">=</span><span class="default_value">'isothermal'</span></em>, <em class="sig-param"><span class="n">initial_temperature</span><span class="o">=</span><span class="default_value">1574</span></em>, <em class="sig-param"><span class="n">temperature_gradient</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cooling_rate</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">temperature_file_path</span><span class="o">=</span><span class="default_value">'T.xdmf'</span></em>, <em class="sig-param"><span class="n">initial_concentration_array</span><span class="o">=</span><span class="default_value">[0.40831]</span></em>, <em class="sig-param"><span class="n">cell_spacing</span><span class="o">=</span><span class="default_value">4.6e-06</span></em>, <em class="sig-param"><span class="n">d_ratio</span><span class="o">=</span><span class="default_value">1.0638297872340425</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">'explicit'</span></em>, <em class="sig-param"><span class="n">nbc</span><span class="o">=</span><span class="default_value">['periodic', 'periodic']</span></em>, <em class="sig-param"><span class="n">cuda_blocks</span><span class="o">=</span><span class="default_value">16, 16</span></em>, <em class="sig-param"><span class="n">cuda_threads_per_block</span><span class="o">=</span><span class="default_value">256, 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.AnisoDorrGPU.init_AnisoDorrGPU" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.AnisoDorrGPU.make_seed">
<code class="sig-prename descclassname">pyphasefield.Engines.AnisoDorrGPU.</code><code class="sig-name descname">make_seed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">q1</span></em>, <em class="sig-param"><span class="n">q4</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">angle</span></em>, <em class="sig-param"><span class="n">seed_radius</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.AnisoDorrGPU.make_seed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyphasefield.Engines.CahnAllen">
<span id="pyphasefield-engines-cahnallen-module"></span><h2>pyphasefield.Engines.CahnAllen module<a class="headerlink" href="#module-pyphasefield.Engines.CahnAllen" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyphasefield.Engines.CahnAllen.CahnAllen">
<em class="property">class </em><code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">CahnAllen</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.CahnAllen" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyphasefield.html#pyphasefield.simulation.Simulation" title="pyphasefield.simulation.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyphasefield.simulation.Simulation</span></code></a></p>
<dl class="py method">
<dt id="pyphasefield.Engines.CahnAllen.CahnAllen.init_fields">
<code class="sig-name descname">init_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.CahnAllen.init_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.CahnAllen.CahnAllen.initialize_fields_and_imported_data">
<code class="sig-name descname">initialize_fields_and_imported_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.CahnAllen.initialize_fields_and_imported_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.CahnAllen.CahnAllen.just_before_simulating">
<code class="sig-name descname">just_before_simulating</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.CahnAllen.just_before_simulating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.CahnAllen.CahnAllen.simulation_loop">
<code class="sig-name descname">simulation_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.CahnAllen.simulation_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.engine_CahnAllenCrankNicolson2D_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">engine_CahnAllenCrankNicolson2D_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.engine_CahnAllenCrankNicolson2D_ADI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.engine_CahnAllenExplicit">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">engine_CahnAllenExplicit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.engine_CahnAllenExplicit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.engine_CahnAllenIMEX1D">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">engine_CahnAllenIMEX1D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.engine_CahnAllenIMEX1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit1D">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">engine_CahnAllenImplicit1D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit1D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">engine_CahnAllenImplicit1D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit1D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit2D_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">engine_CahnAllenImplicit2D_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit2D_ADI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit2D_ADI_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">engine_CahnAllenImplicit2D_ADI_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit2D_ADI_GMRES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit2D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">engine_CahnAllenImplicit2D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit2D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit3D_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">engine_CahnAllenImplicit3D_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.engine_CahnAllenImplicit3D_ADI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.functional_CahnAllen">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">functional_CahnAllen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.functional_CahnAllen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.implicit_matrix_1d">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">implicit_matrix_1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xsize</span></em>, <em class="sig-param"><span class="n">centervalue</span></em>, <em class="sig-param"><span class="n">neighborvalue</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.implicit_matrix_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a matrix for the solution of 1d implicit or crank nickolson discretizations</p>
<p>Because the exact format changes between implicit and C-N, and this method is reused
in 2D and 3D cases, centervalue and neighbor value must be explicitly specified</p>
<p>Matrix shows periodic boundary conditions!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xsize</strong> (<em>int</em>) – Size of one dimension of the square NxN implicit matrix, equal to the number of elements in the 1D phase field model</p></li>
<li><p><strong>centervalue</strong> (<em>float</em>) – Value inserted into the central diagonal of the implicit matrix.</p></li>
<li><p><strong>neighborvalue</strong> (<em>float</em>) – Value inserted into the two just-off-center diagonals of the implicit matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D NumPy ndarray representation of implicit matrix, with shape [xsize*ysize, xsize*ysize]</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Consider the implicit 1D diffusion matrix with generic discretization term equal to the following:</p>
<p>$$(c_{x}^{t+1} - c_{x}^{t})/dt = (D/(Delta x^2))(c_{x+1}^{t+1} + c_{x-1}^{t+1} - 2c_{x}^{t+1})$$</p>
<p>This can be rearranged as to express c_{x}^{t} as a function of c_{x}^{t+1}, c_{x-1}^{t+1}, and c_{x+1}^{t+1}
(Also, let a = D*dt/(Delta x^2) ):</p>
<p>$$c_{x}^{t} = (-a)c_{x+1}^{t+1} + (-a)c_{x-1}^{t+1} + (1+2a)c_{x}^{t+1}$$</p>
<p>The implicit matrix composed of these terms is defined as follows:
The central diagonal (centervalue) equals the coefficient of c_{x}^{t+1}: 1+2a, or 1+2*D*Delta t/(Delta x^2)
The neighboring diagonals to the center (neighborvalue) equals the coefficient of c_{x-1}^{t+1} or c_{x+1}^{t+1}:
-a, or -D*Delta t/(Delta x^2)</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnAllen.implicit_matrix_2d">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnAllen.</code><code class="sig-name descname">implicit_matrix_2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ysize</span></em>, <em class="sig-param"><span class="n">xsize</span></em>, <em class="sig-param"><span class="n">centervalue</span></em>, <em class="sig-param"><span class="n">neighborvalue</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnAllen.implicit_matrix_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a matrix for the solution of 2d implicit or crank nickolson discretizations</p>
<p>Because the exact format changes between implicit and C-N, and this method is reused
in 3D cases, centervalue and neighbor value must be explicitly specified</p>
<p>Parameter order is specified as ysize then xsize, because the dimensional order of 2d arrays is [y, x]</p>
<p>Matrix shows periodic boundary conditions!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ysize</strong> (<em>int</em>) – Equal to the number of elements along the y-axis in the 2D phase field model
xsize*ysize is equal to the length of one dimension of the square NxN implicit matrix</p></li>
<li><p><strong>xsize</strong> (<em>int</em>) – Equal to the number of elements along the x-axis in the 2D phase field model
xsize*ysize is equal to the length of one dimension of the square NxN implicit matrix</p></li>
<li><p><strong>centervalue</strong> (<em>float</em>) – Value inserted into the central diagonal of the implicit matrix.</p></li>
<li><p><strong>neighborvalue</strong> (<em>float</em>) – Value inserted into the four just-off-center diagonals of the 2D implicit matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D NumPy ndarray representation of implicit matrix, with shape [xsize*ysize, xsize*ysize]</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Consider the implicit 2D diffusion matrix with generic discretization term equal to the following:</p>
<p>$$(c_{x, y}^{t+1} - c_{x, y}^{t})/dt = (D/(Delta x^2))(c_{x+1, y}^{t+1} + c_{x-1, y}^{t+1}
+ c_{x, y+1}^{t+1} + c_{x, y-1}^{t+1} - 4c_{x, y}^{t+1})$$</p>
<p>This can be rearranged as to express c_{x, y}^{t} as a function of c_{x, y}^{t+1}, c_{x-1, y}^{t+1},
c_{x+1, y}^{t+1}, c_{x, y-1}^{t+1}, and c_{x, y+1}^{t+1}
(Also, let a = D*dt/(Delta x^2) ):</p>
<p>$$c_{x, y}^{t} = (-a)c_{x+1, y}^{t+1} + (-a)c_{x-1, y}^{t+1} + (-a)c_{x, y+1}^{t+1}
+ (-a)c_{x, y-1}^{t+1} + (1+4a)c_{x, y}^{t+1}$$</p>
<p>The implicit matrix composed of these terms is defined as follows:
The central diagonal (centervalue) equals the coefficient of c_{x, y}^{t+1}: 1+4a, or 1+4*D*Delta t/(Delta x^2)
The neighboring diagonals to the center (neighborvalue) equals the coefficient of c_{x-1, y}^{t+1} (or other similar terms):
-a, or -D*Delta t/(Delta x^2)</p>
<p>Note that two of the “neighboring” diagonals are separated by a significant number of cells in the matrix, however
they are still considered to be “neighbors” conceptually</p>
</dd></dl>

</div>
<div class="section" id="module-pyphasefield.Engines.CahnHilliard">
<span id="pyphasefield-engines-cahnhilliard-module"></span><h2>pyphasefield.Engines.CahnHilliard module<a class="headerlink" href="#module-pyphasefield.Engines.CahnHilliard" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyphasefield.Engines.CahnHilliard.CahnHilliard">
<em class="property">class </em><code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">CahnHilliard</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.CahnHilliard" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyphasefield.html#pyphasefield.simulation.Simulation" title="pyphasefield.simulation.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyphasefield.simulation.Simulation</span></code></a></p>
<dl class="py method">
<dt id="pyphasefield.Engines.CahnHilliard.CahnHilliard.init_fields">
<code class="sig-name descname">init_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.CahnHilliard.init_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.CahnHilliard.CahnHilliard.initialize_fields_and_imported_data">
<code class="sig-name descname">initialize_fields_and_imported_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.CahnHilliard.initialize_fields_and_imported_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.CahnHilliard.CahnHilliard.just_before_simulating">
<code class="sig-name descname">just_before_simulating</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.CahnHilliard.just_before_simulating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.CahnHilliard.CahnHilliard.simulation_loop">
<code class="sig-name descname">simulation_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.CahnHilliard.simulation_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardCrankNicolson1D">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardCrankNicolson1D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardCrankNicolson1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardCrankNicolson1D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardCrankNicolson1D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardCrankNicolson1D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardCrankNicolson2D_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardCrankNicolson2D_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardCrankNicolson2D_ADI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardExplicit">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardExplicit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardExplicit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardIMEX1D">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardIMEX1D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardIMEX1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit1D">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardImplicit1D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit1D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardImplicit1D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit1D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit2D_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardImplicit2D_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit2D_ADI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit2D_ADI_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardImplicit2D_ADI_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit2D_ADI_GMRES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit2D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardImplicit2D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit2D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit3D_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">engine_CahnHilliardImplicit3D_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.engine_CahnHilliardImplicit3D_ADI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.functional_CahnHilliard">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">functional_CahnHilliard</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.functional_CahnHilliard" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.implicit_matrix_1d">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">implicit_matrix_1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xsize</span></em>, <em class="sig-param"><span class="n">centervalue</span></em>, <em class="sig-param"><span class="n">neighborvalue</span></em>, <em class="sig-param"><span class="n">farneighborvalue</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.implicit_matrix_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a matrix for the solution of 1d implicit or crank nickolson discretizations</p>
<p>Because the exact format changes between implicit and C-N, and this method is reused
in 2D and 3D cases, centervalue and neighbor value must be explicitly specified</p>
<p>Matrix shows periodic boundary conditions!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xsize</strong> (<em>int</em>) – Size of one dimension of the square NxN implicit matrix, equal to the number of elements in the 1D phase field model</p></li>
<li><p><strong>centervalue</strong> (<em>float</em>) – Value inserted into the central diagonal of the implicit matrix.</p></li>
<li><p><strong>neighborvalue</strong> (<em>float</em>) – Value inserted into the two just-off-center diagonals of the implicit matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D NumPy ndarray representation of implicit matrix, with shape [xsize, xsize]</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Consider the implicit 1D diffusion matrix with generic discretization term equal to the following:</p>
<p>$$(c_{x}^{t+1} - c_{x}^{t})/dt = (D/(Delta x^2))(c_{x+1}^{t+1} + c_{x-1}^{t+1} - 2c_{x}^{t+1})$$</p>
<p>This can be rearranged as to express c_{x}^{t} as a function of c_{x}^{t+1}, c_{x-1}^{t+1}, and c_{x+1}^{t+1}
(Also, let a = D*dt/(Delta x^2) ):</p>
<p>$$c_{x}^{t} = (-a)c_{x+1}^{t+1} + (-a)c_{x-1}^{t+1} + (1+2a)c_{x}^{t+1}$$</p>
<p>The implicit matrix composed of these terms is defined as follows:
The central diagonal (centervalue) equals the coefficient of c_{x}^{t+1}: 1+2a, or 1+2*D*Delta t/(Delta x^2)
The neighboring diagonals to the center (neighborvalue) equals the coefficient of c_{x-1}^{t+1} or c_{x+1}^{t+1}:
-a, or -D*Delta t/(Delta x^2)</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.CahnHilliard.implicit_matrix_2d">
<code class="sig-prename descclassname">pyphasefield.Engines.CahnHilliard.</code><code class="sig-name descname">implicit_matrix_2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ysize</span></em>, <em class="sig-param"><span class="n">xsize</span></em>, <em class="sig-param"><span class="n">centervalue</span></em>, <em class="sig-param"><span class="n">neighborvalue</span></em>, <em class="sig-param"><span class="n">farneighborvalue</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.CahnHilliard.implicit_matrix_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a matrix for the solution of 2d implicit or crank nickolson discretizations</p>
<p>Because the exact format changes between implicit and C-N, and this method is reused
in 3D cases, centervalue and neighbor value must be explicitly specified</p>
<p>Parameter order is specified as ysize then xsize, because the dimensional order of 2d arrays is [y, x]</p>
<p>Matrix shows periodic boundary conditions!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ysize</strong> (<em>int</em>) – Equal to the number of elements along the y-axis in the 2D phase field model
xsize*ysize is equal to the length of one dimension of the square NxN implicit matrix</p></li>
<li><p><strong>xsize</strong> (<em>int</em>) – Equal to the number of elements along the x-axis in the 2D phase field model
xsize*ysize is equal to the length of one dimension of the square NxN implicit matrix</p></li>
<li><p><strong>centervalue</strong> (<em>float</em>) – Value inserted into the central diagonal of the implicit matrix.</p></li>
<li><p><strong>neighborvalue</strong> (<em>float</em>) – Value inserted into the four just-off-center diagonals of the 2D implicit matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D NumPy ndarray representation of implicit matrix, with shape [xsize*ysize, xsize*ysize]</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Consider the implicit 2D diffusion matrix with generic discretization term equal to the following:</p>
<p>$$(c_{x, y}^{t+1} - c_{x, y}^{t})/dt = (D/(Delta x^2))(c_{x+1, y}^{t+1} + c_{x-1, y}^{t+1}
+ c_{x, y+1}^{t+1} + c_{x, y-1}^{t+1} - 4c_{x, y}^{t+1})$$</p>
<p>This can be rearranged as to express c_{x, y}^{t} as a function of c_{x, y}^{t+1}, c_{x-1, y}^{t+1},
c_{x+1, y}^{t+1}, c_{x, y-1}^{t+1}, and c_{x, y+1}^{t+1}
(Also, let a = D*dt/(Delta x^2) ):</p>
<p>$$c_{x, y}^{t} = (-a)c_{x+1, y}^{t+1} + (-a)c_{x-1, y}^{t+1} + (-a)c_{x, y+1}^{t+1}
+ (-a)c_{x, y-1}^{t+1} + (1+4a)c_{x, y}^{t+1}$$</p>
<p>The implicit matrix composed of these terms is defined as follows:
The central diagonal (centervalue) equals the coefficient of c_{x, y}^{t+1}: 1+4a, or 1+4*D*Delta t/(Delta x^2)
The neighboring diagonals to the center (neighborvalue) equals the coefficient of c_{x-1, y}^{t+1} (or other similar terms):
-a, or -D*Delta t/(Delta x^2)</p>
<p>Note that two of the “neighboring” diagonals are separated by a significant number of cells in the matrix, however
they are still considered to be “neighbors” conceptually</p>
</dd></dl>

</div>
<div class="section" id="module-pyphasefield.Engines.Diffusion">
<span id="pyphasefield-engines-diffusion-module"></span><h2>pyphasefield.Engines.Diffusion module<a class="headerlink" href="#module-pyphasefield.Engines.Diffusion" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyphasefield.Engines.Diffusion.Diffusion">
<em class="property">class </em><code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">Diffusion</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.Diffusion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyphasefield.html#pyphasefield.simulation.Simulation" title="pyphasefield.simulation.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyphasefield.simulation.Simulation</span></code></a></p>
<dl class="py method">
<dt id="pyphasefield.Engines.Diffusion.Diffusion.init_fields">
<code class="sig-name descname">init_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.Diffusion.init_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.Diffusion.Diffusion.initialize_fields_and_imported_data">
<code class="sig-name descname">initialize_fields_and_imported_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.Diffusion.initialize_fields_and_imported_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.Diffusion.Diffusion.just_before_simulating">
<code class="sig-name descname">just_before_simulating</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.Diffusion.just_before_simulating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.Diffusion.Diffusion.simulation_loop">
<code class="sig-name descname">simulation_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.Diffusion.simulation_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.diffusion_matrix_1d">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">diffusion_matrix_1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xsize</span></em>, <em class="sig-param"><span class="n">centervalue</span></em>, <em class="sig-param"><span class="n">neighborvalue</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.diffusion_matrix_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a matrix for the solution of 1d implicit or crank nickolson discretizations</p>
<p>Because the exact format changes between implicit and C-N, and this method is reused
in 2D and 3D cases, centervalue and neighbor value must be explicitly specified</p>
<p>Matrix shows periodic boundary conditions!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xsize</strong> (<em>int</em>) – Size of one dimension of the square NxN implicit matrix, equal to the number of elements in the 1D phase field model</p></li>
<li><p><strong>centervalue</strong> (<em>float</em>) – Value inserted into the central diagonal of the implicit matrix.</p></li>
<li><p><strong>neighborvalue</strong> (<em>float</em>) – Value inserted into the two just-off-center diagonals of the implicit matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D NumPy ndarray representation of implicit matrix, with shape [xsize, xsize]</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Consider the implicit 1D diffusion matrix with generic discretization term equal to the following:</p>
<p>$$(c_{x}^{t+1} - c_{x}^{t})/dt = (D/(Delta x^2))(c_{x+1}^{t+1} + c_{x-1}^{t+1} - 2c_{x}^{t+1})$$</p>
<p>This can be rearranged as to express c_{x}^{t} as a function of c_{x}^{t+1}, c_{x-1}^{t+1}, and c_{x+1}^{t+1}
(Also, let a = D*dt/(Delta x^2) ):</p>
<p>$$c_{x}^{t} = (-a)c_{x+1}^{t+1} + (-a)c_{x-1}^{t+1} + (1+2a)c_{x}^{t+1}$$</p>
<p>The implicit matrix composed of these terms is defined as follows:
The central diagonal (centervalue) equals the coefficient of c_{x}^{t+1}: 1+2a, or 1+2*D*Delta t/(Delta x^2)
The neighboring diagonals to the center (neighborvalue) equals the coefficient of c_{x-1}^{t+1} or c_{x+1}^{t+1}:
-a, or -D*Delta t/(Delta x^2)</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.diffusion_matrix_2d">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">diffusion_matrix_2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ysize</span></em>, <em class="sig-param"><span class="n">xsize</span></em>, <em class="sig-param"><span class="n">centervalue</span></em>, <em class="sig-param"><span class="n">neighborvalue</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.diffusion_matrix_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a matrix for the solution of 2d implicit or crank nickolson discretizations</p>
<p>Because the exact format changes between implicit and C-N, and this method is reused
in 3D cases, centervalue and neighbor value must be explicitly specified</p>
<p>Parameter order is specified as ysize then xsize, because the dimensional order of 2d arrays is [y, x]</p>
<p>Matrix shows periodic boundary conditions!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ysize</strong> (<em>int</em>) – Equal to the number of elements along the y-axis in the 2D phase field model
xsize*ysize is equal to the length of one dimension of the square NxN implicit matrix</p></li>
<li><p><strong>xsize</strong> (<em>int</em>) – Equal to the number of elements along the x-axis in the 2D phase field model
xsize*ysize is equal to the length of one dimension of the square NxN implicit matrix</p></li>
<li><p><strong>centervalue</strong> (<em>float</em>) – Value inserted into the central diagonal of the implicit matrix.</p></li>
<li><p><strong>neighborvalue</strong> (<em>float</em>) – Value inserted into the four just-off-center diagonals of the 2D implicit matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D NumPy ndarray representation of implicit matrix, with shape [xsize*ysize, xsize*ysize]</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Consider the implicit 2D diffusion matrix with generic discretization term equal to the following:</p>
<p>$$(c_{x, y}^{t+1} - c_{x, y}^{t})/dt = (D/(Delta x^2))(c_{x+1, y}^{t+1} + c_{x-1, y}^{t+1}
+ c_{x, y+1}^{t+1} + c_{x, y-1}^{t+1} - 4c_{x, y}^{t+1})$$</p>
<p>This can be rearranged as to express c_{x, y}^{t} as a function of c_{x, y}^{t+1}, c_{x-1, y}^{t+1},
c_{x+1, y}^{t+1}, c_{x, y-1}^{t+1}, and c_{x, y+1}^{t+1}
(Also, let a = D*dt/(Delta x^2) ):</p>
<p>$$c_{x, y}^{t} = (-a)c_{x+1, y}^{t+1} + (-a)c_{x-1, y}^{t+1} + (-a)c_{x, y+1}^{t+1}
+ (-a)c_{x, y-1}^{t+1} + (1+4a)c_{x, y}^{t+1}$$</p>
<p>The implicit matrix composed of these terms is defined as follows:
The central diagonal (centervalue) equals the coefficient of c_{x, y}^{t+1}: 1+4a, or 1+4*D*Delta t/(Delta x^2)
The neighboring diagonals to the center (neighborvalue) equals the coefficient of c_{x-1, y}^{t+1} (or other similar terms):
-a, or -D*Delta t/(Delta x^2)</p>
<p>Note that two of the “neighboring” diagonals are separated by a significant number of cells in the matrix, however
they are still considered to be “neighbors” conceptually</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.diffusion_matrix_3d">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">diffusion_matrix_3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zsize</span></em>, <em class="sig-param"><span class="n">ysize</span></em>, <em class="sig-param"><span class="n">xsize</span></em>, <em class="sig-param"><span class="n">centervalue</span></em>, <em class="sig-param"><span class="n">neighborvalue</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.diffusion_matrix_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a matrix for the solution of 3d implicit or crank nickolson discretizations</p>
<p>Because the exact format changes between implicit and C-N, centervalue and neighbor
value must be explicitly specified</p>
<p>Parameter order is specified as zsize then ysize then xsize, because the dimensional order of 3d arrays is [z, y, x]</p>
<p>Matrix shows periodic boundary conditions!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zsize</strong> (<em>int</em>) – Equal to the number of elements along the z-axis in the 3D phase field model
xsize*ysize*zsize is equal to the length of one dimension of the square NxN implicit matrix</p></li>
<li><p><strong>ysize</strong> (<em>int</em>) – Equal to the number of elements along the y-axis in the 3D phase field model
xsize*ysize*zsize is equal to the length of one dimension of the square NxN implicit matrix</p></li>
<li><p><strong>xsize</strong> (<em>int</em>) – Equal to the number of elements along the x-axis in the 3D phase field model
xsize*ysize*zsize is equal to the length of one dimension of the square NxN implicit matrix</p></li>
<li><p><strong>centervalue</strong> (<em>float</em>) – Value inserted into the central diagonal of the implicit matrix.</p></li>
<li><p><strong>neighborvalue</strong> (<em>float</em>) – Value inserted into the six just-off-center diagonals of the 3D implicit matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D NumPy ndarray representation of implicit matrix, with shape [xsize*ysize*zsize, xsize*ysize*zsize]</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Non-ADI, non-GMRES 3d implicit or C-N solvers will be <strong>extremely</strong> slow unless they are <em>very</em> small!</p>
</div>
<p class="rubric">Notes</p>
<p>Consider the implicit 3D diffusion matrix with generic discretization term equal to the following:</p>
<p>$$(c_{x, y, z}^{t+1} - c_{x, y, z}^{t})/dt = (D/(Delta x^2))(c_{x+1, y, z}^{t+1} + c_{x-1, y, z}^{t+1}
+ c_{x, y+1, z}^{t+1} + c_{x, y-1, z}^{t+1} + c_{x, y, z+1}^{t+1} + c_{x, y, z-1}^{t+1} - 6c_{x, y, z}^{t+1})$$</p>
<p>This can be rearranged as to express c_{x, y, z}^{t} as a function of c_{x, y, z}^{t+1}, c_{x-1, y, z}^{t+1},
c_{x+1, y, z}^{t+1}, c_{x, y-1, z}^{t+1}, and c_{x, y+1, z}^{t+1}
(Also, let a = D*dt/(Delta x^2) ):</p>
<p>$$c_{x, y, z}^{t} = (-a)c_{x+1, y, z}^{t+1} + (-a)c_{x-1, y, z}^{t+1} + (-a)c_{x, y+1, z}^{t+1} + (-a)c_{x, y-1, z}^{t+1}
+ (-a)c_{x, y, z+1}^{t+1} + (-a)c_{x, y, z-1}^{t+1} + (1+6a)c_{x, y, z}^{t+1}$$</p>
<p>The implicit matrix composed of these terms is defined as follows:
The central diagonal (centervalue) equals the coefficient of c_{x, y, z}^{t+1}: 1+6a, or 1+6*D*Delta t/(Delta x^2)
The neighboring diagonals to the center (neighborvalue) equals the coefficient of c_{x-1, y, z}^{t+1} (or other similar terms):
-a, or -D*Delta t/(Delta x^2)</p>
<p>Note that four of the “neighboring” diagonals are separated by a significant number of cells in the matrix, however
they are still considered to be “neighbors” conceptually</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion1D">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_CrankNicolsonDiffusion1D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Crank-Nicolson method in 1D</p>
<p>Uses the function np.linalg.solve(A, b) to solve the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion1D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_CrankNicolsonDiffusion1D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion1D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Crank-Nicolson method in 1D</p>
<p>Uses the function scipy.sparse.linalg.gmres(A, b) to <strong>quickly but approximately</strong> solve
the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion2D">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_CrankNicolsonDiffusion2D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Crank-Nicolson method in 2D
Uses the function np.linalg.solve(A, b) to solve the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion2D_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_CrankNicolsonDiffusion2D_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion2D_ADI" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Alternating Direction Implicit method for 2D,
extended to use the Crank-Nicolson scheme</p>
<p>Uses the Peaceman-Rachford discretization (explicit x + implicit y, then explicit y + implicit x)</p>
<p>Uses the function np.linalg.inv(A) to compute A^-1 directly, since it is reused several times</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion2D_ADI_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_CrankNicolsonDiffusion2D_ADI_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion2D_ADI_GMRES" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Alternating Direction Implicit method for 2D,
extended to use the Crank-Nicolson scheme</p>
<p>Uses the Peaceman-Rachford discretization (explicit x + implicit y, then explicit y + implicit x)</p>
<p>Uses the function scipy.sparse.linalg.gmres(A, b) to <strong>quickly but approximately</strong> solve
the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion2D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_CrankNicolsonDiffusion2D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion2D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Crank-Nicolson method in 2D</p>
<p>Uses the function scipy.sparse.linalg.gmres(A, b) to <strong>quickly but approximately</strong> solve
the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion3D">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_CrankNicolsonDiffusion3D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Crank-Nicolson method in 3D</p>
<p>Uses the function np.linalg.solve(A, b) to solve the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion3D_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_CrankNicolsonDiffusion3D_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion3D_ADI" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Alternating Direction Implicit method for 3D,
extended to use the Crank-Nicolson scheme</p>
<p>Uses an extended Peaceman-Rachford discretization (explicit x + implicit y, then explicit y + implicit z,
then explicit z + implicit x)</p>
<p>Uses the function np.linalg.inv(A) to compute A^-1 directly, since it is reused several times</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion3D_ADI_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_CrankNicolsonDiffusion3D_ADI_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion3D_ADI_GMRES" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Alternating Direction Implicit method for 3D,
extended to use the Crank-Nicolson scheme</p>
<p>Uses an extended Peaceman-Rachford discretization (explicit x + implicit y, then explicit y + implicit z,
then explicit z + implicit x)</p>
<p>Uses the function scipy.sparse.linalg.gmres(A, b) to <strong>quickly but approximately</strong> solve
the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion3D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_CrankNicolsonDiffusion3D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_CrankNicolsonDiffusion3D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Crank-Nicolson method in 3D</p>
<p>Uses the function scipy.sparse.linalg.gmres(A, b) to <strong>quickly but approximately</strong> solve
the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ExplicitDiffusion">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ExplicitDiffusion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ExplicitDiffusion" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using a purely explicit scheme</p>
<p>Valid for 1, 2, or 3D simulations</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion1D">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ImplicitDiffusion1D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using a purely implicit scheme in 1D</p>
<p>Uses the function np.linalg.solve(A, b) to solve the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion1D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ImplicitDiffusion1D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion1D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using a purely implicit scheme in 1D</p>
<p>Uses the function scipy.sparse.linalg.gmres(A, b) to <strong>quickly but approximately</strong> solve
the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion2D">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ImplicitDiffusion2D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using a purely implicit scheme in 2D</p>
<p>Uses the function np.linalg.solve(A, b) to solve the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion2D_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ImplicitDiffusion2D_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion2D_ADI" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Alternating Direction Implicit method for 2D</p>
<p>Uses the function np.linalg.inv(A) to compute A^-1 directly, since it is reused several times</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion2D_ADI_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ImplicitDiffusion2D_ADI_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion2D_ADI_GMRES" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Alternating Direction Implicit method for 2D</p>
<p>Uses the function scipy.sparse.linalg.gmres(A, b) to <strong>quickly but approximately</strong> solve
the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion2D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ImplicitDiffusion2D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion2D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using a purely implicit scheme in 2D</p>
<p>Uses the function scipy.sparse.linalg.gmres(A, b) to <strong>quickly but approximately</strong> solve
the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion3D">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ImplicitDiffusion3D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using a purely implicit scheme in 3D</p>
<p>Uses the function np.linalg.solve(A, b) to solve the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion3D_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ImplicitDiffusion3D_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion3D_ADI" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Alternating Direction Implicit method for 2D</p>
<p>Uses the function np.linalg.inv(A) to compute A^-1 directly, since it is reused several times</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion3D_ADI_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ImplicitDiffusion3D_ADI_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion3D_ADI_GMRES" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using the Alternating Direction Implicit method for 2D</p>
<p>Uses the function scipy.sparse.linalg.gmres(A, b) to <strong>quickly but approximately</strong> solve
the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion3D_GMRES">
<code class="sig-prename descclassname">pyphasefield.Engines.Diffusion.</code><code class="sig-name descname">engine_ImplicitDiffusion3D_GMRES</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Diffusion.engine_ImplicitDiffusion3D_GMRES" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretization of the diffusion equation using a purely implicit scheme in 3D</p>
<p>Uses the function scipy.sparse.linalg.gmres(A, b) to <strong>quickly but approximately</strong> solve
the equation Ax=b for the matrix A and vectors x and b</p>
</dd></dl>

</div>
<div class="section" id="module-pyphasefield.Engines.DiffusionGPU">
<span id="pyphasefield-engines-diffusiongpu-module"></span><h2>pyphasefield.Engines.DiffusionGPU module<a class="headerlink" href="#module-pyphasefield.Engines.DiffusionGPU" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyphasefield.Engines.DiffusionGPU.DiffusionGPU">
<em class="property">class </em><code class="sig-prename descclassname">pyphasefield.Engines.DiffusionGPU.</code><code class="sig-name descname">DiffusionGPU</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.DiffusionGPU.DiffusionGPU" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyphasefield.html#pyphasefield.simulation.Simulation" title="pyphasefield.simulation.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyphasefield.simulation.Simulation</span></code></a></p>
<dl class="py method">
<dt id="pyphasefield.Engines.DiffusionGPU.DiffusionGPU.init_fields">
<code class="sig-name descname">init_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.DiffusionGPU.DiffusionGPU.init_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.DiffusionGPU.DiffusionGPU.initialize_fields_and_imported_data">
<code class="sig-name descname">initialize_fields_and_imported_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.DiffusionGPU.DiffusionGPU.initialize_fields_and_imported_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.DiffusionGPU.DiffusionGPU.just_before_simulating">
<code class="sig-name descname">just_before_simulating</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.DiffusionGPU.DiffusionGPU.just_before_simulating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.DiffusionGPU.DiffusionGPU.simulation_loop">
<code class="sig-name descname">simulation_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.DiffusionGPU.DiffusionGPU.simulation_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.DiffusionGPU.engine_DiffusionGPU">
<code class="sig-prename descclassname">pyphasefield.Engines.DiffusionGPU.</code><code class="sig-name descname">engine_DiffusionGPU</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.DiffusionGPU.engine_DiffusionGPU" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyphasefield.Engines.NCGPU">
<span id="pyphasefield-engines-ncgpu-module"></span><h2>pyphasefield.Engines.NCGPU module<a class="headerlink" href="#module-pyphasefield.Engines.NCGPU" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyphasefield.Engines.NCGPU.NCGPU">
<em class="property">class </em><code class="sig-prename descclassname">pyphasefield.Engines.NCGPU.</code><code class="sig-name descname">NCGPU</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU.NCGPU" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyphasefield.html#pyphasefield.simulation.Simulation" title="pyphasefield.simulation.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyphasefield.simulation.Simulation</span></code></a></p>
<dl class="py method">
<dt id="pyphasefield.Engines.NCGPU.NCGPU.init_fields">
<code class="sig-name descname">init_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU.NCGPU.init_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.NCGPU.NCGPU.init_tdb_params">
<code class="sig-name descname">init_tdb_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU.NCGPU.init_tdb_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.NCGPU.NCGPU.just_before_simulating">
<code class="sig-name descname">just_before_simulating</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU.NCGPU.just_before_simulating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.NCGPU.NCGPU.simulation_loop">
<code class="sig-name descname">simulation_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU.NCGPU.simulation_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NCGPU.get_thermodynamics">
<code class="sig-prename descclassname">pyphasefield.Engines.NCGPU.</code><code class="sig-name descname">get_thermodynamics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ufunc</span></em>, <em class="sig-param"><span class="n">array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU.get_thermodynamics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NCGPU.make_seed">
<code class="sig-prename descclassname">pyphasefield.Engines.NCGPU.</code><code class="sig-name descname">make_seed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">q1</span></em>, <em class="sig-param"><span class="n">q4</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">angle</span></em>, <em class="sig-param"><span class="n">seed_radius</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU.make_seed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NCGPU.npvalue">
<code class="sig-prename descclassname">pyphasefield.Engines.NCGPU.</code><code class="sig-name descname">npvalue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">tdb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU.npvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a numpy float from the sympy expression gotten from pycalphad
Reason: some numpy functions (i.e. sqrt) are incompatible with sympy floats!</p>
</dd></dl>

</div>
<div class="section" id="module-pyphasefield.Engines.NCGPU_new">
<span id="pyphasefield-engines-ncgpu-new-module"></span><h2>pyphasefield.Engines.NCGPU_new module<a class="headerlink" href="#module-pyphasefield.Engines.NCGPU_new" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyphasefield.Engines.NCGPU_new.NCGPU_new">
<em class="property">class </em><code class="sig-prename descclassname">pyphasefield.Engines.NCGPU_new.</code><code class="sig-name descname">NCGPU_new</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU_new.NCGPU_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyphasefield.html#pyphasefield.simulation.Simulation" title="pyphasefield.simulation.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyphasefield.simulation.Simulation</span></code></a></p>
<dl class="py method">
<dt id="pyphasefield.Engines.NCGPU_new.NCGPU_new.init_fields">
<code class="sig-name descname">init_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU_new.NCGPU_new.init_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.NCGPU_new.NCGPU_new.init_tdb_params">
<code class="sig-name descname">init_tdb_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU_new.NCGPU_new.init_tdb_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.NCGPU_new.NCGPU_new.just_before_simulating">
<code class="sig-name descname">just_before_simulating</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU_new.NCGPU_new.just_before_simulating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.NCGPU_new.NCGPU_new.simulation_loop">
<code class="sig-name descname">simulation_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU_new.NCGPU_new.simulation_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NCGPU_new.get_thermodynamics">
<code class="sig-prename descclassname">pyphasefield.Engines.NCGPU_new.</code><code class="sig-name descname">get_thermodynamics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ufunc</span></em>, <em class="sig-param"><span class="n">array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU_new.get_thermodynamics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NCGPU_new.make_seed">
<code class="sig-prename descclassname">pyphasefield.Engines.NCGPU_new.</code><code class="sig-name descname">make_seed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">q1</span></em>, <em class="sig-param"><span class="n">q4</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">angle</span></em>, <em class="sig-param"><span class="n">seed_radius</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU_new.make_seed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NCGPU_new.npvalue">
<code class="sig-prename descclassname">pyphasefield.Engines.NCGPU_new.</code><code class="sig-name descname">npvalue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">tdb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NCGPU_new.npvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a numpy float from the sympy expression gotten from pycalphad
Reason: some numpy functions (i.e. sqrt) are incompatible with sympy floats!</p>
</dd></dl>

</div>
<div class="section" id="module-pyphasefield.Engines.NComponent">
<span id="pyphasefield-engines-ncomponent-module"></span><h2>pyphasefield.Engines.NComponent module<a class="headerlink" href="#module-pyphasefield.Engines.NComponent" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.add_nuclei">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">add_nuclei</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">q1</span></em>, <em class="sig-param"><span class="n">q4</span></em>, <em class="sig-param"><span class="n">p11</span></em>, <em class="sig-param"><span class="n">size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.add_nuclei" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.compute_tdb_energy_nc">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">compute_tdb_energy_nc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em>, <em class="sig-param"><span class="n">temps</span></em>, <em class="sig-param"><span class="n">c</span></em>, <em class="sig-param"><span class="n">phase</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.compute_tdb_energy_nc" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes Gibbs Free Energy and its derivative*S* w.r.t. composition, for a given temperature field and list of composition fields
Derivatives are computed by holding all other explicit composition variables constant
c_i is increased, c_N is decreased (the implicitly-defined last composition variable which equals 1-sum(c_i) )</p>
<dl class="simple">
<dt>Input parameters:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>sim: the Simulation object. The method retrieves the TDB pycalphad object (sim._tdb) and the components used (sim._components)</dt><dd><p>from this variable.</p>
</dd>
</dl>
</li>
<li><p>temps: the temperature array. Could also be retrieved as sim.temperature</p></li>
<li><p>c: the list of composition arrays. The format is a python list of numpy ndarrays</p></li>
<li><p>phase: the String which corresponds to a particular phase in the TDB file. E.g.: “FCC_A1” or “LIQUID”</p></li>
</ul>
</dd>
</dl>
<p>Returns GM (Molar Gibbs Free Energy) and dGdci (list of derivatives of GM, w.r.t. c_i)</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.compute_tdb_energy_nc_rev">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">compute_tdb_energy_nc_rev</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em>, <em class="sig-param"><span class="n">temps</span></em>, <em class="sig-param"><span class="n">c</span></em>, <em class="sig-param"><span class="n">phase</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.compute_tdb_energy_nc_rev" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes Gibbs Free Energy and its derivative*S* w.r.t. composition, for a given temperature field and list of composition fields
Derivatives are computed by holding all other explicit composition variables constant
c_i is increased, c_N is decreased (the implicitly-defined last composition variable which equals 1-sum(c_i) )</p>
<dl class="simple">
<dt>Input parameters:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>sim: the Simulation object. The method retrieves the TDB pycalphad object (sim._tdb) and the components used (sim._components)</dt><dd><p>from this variable.</p>
</dd>
</dl>
</li>
<li><p>temps: the temperature array. Could also be retrieved as sim.temperature</p></li>
<li><p>c: the list of composition arrays. The format is a python list of numpy ndarrays</p></li>
<li><p>phase: the String which corresponds to a particular phase in the TDB file. E.g.: “FCC_A1” or “LIQUID”</p></li>
</ul>
</dd>
</dl>
<p>Returns GM (Molar Gibbs Free Energy) and dGdci (list of derivatives of GM, w.r.t. c_i)</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.discretization_NComponent">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">discretization_NComponent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.discretization_NComponent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.divagradb">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">divagradb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.divagradb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.engine_NComponent_ADI">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">engine_NComponent_ADI</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.engine_NComponent_ADI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.engine_NComponent_AnisoM">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">engine_NComponent_AnisoM</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.engine_NComponent_AnisoM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.engine_NComponent_Explicit">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">engine_NComponent_Explicit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.engine_NComponent_Explicit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.engine_NComponent_FrozenOrientation">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">engine_NComponent_FrozenOrientation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.engine_NComponent_FrozenOrientation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.engine_params_NComponent">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">engine_params_NComponent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.engine_params_NComponent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.find_Pn">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">find_Pn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">T_M</span></em>, <em class="sig-param"><span class="n">T</span></em>, <em class="sig-param"><span class="n">Q</span></em>, <em class="sig-param"><span class="n">dt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.find_Pn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.functional_NComponent">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">functional_NComponent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.functional_NComponent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.gaq">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">gaq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gql</span></em>, <em class="sig-param"><span class="n">gqr</span></em>, <em class="sig-param"><span class="n">rgqsl</span></em>, <em class="sig-param"><span class="n">rgqsr</span></em>, <em class="sig-param"><span class="n">dqc</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.gaq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.grad2">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">grad2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.grad2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.grad_c">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">grad_c</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.grad_c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.grad_l">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">grad_l</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.grad_l" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.grad_r">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">grad_r</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.grad_r" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.init_NComponent">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">init_NComponent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em>, <em class="sig-param"><span class="n">dim</span><span class="o">=</span><span class="default_value">[200, 200]</span></em>, <em class="sig-param"><span class="n">sim_type</span><span class="o">=</span><span class="default_value">'seed'</span></em>, <em class="sig-param"><span class="n">number_of_seeds</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">tdb_path</span><span class="o">=</span><span class="default_value">'Ni-Cu_Ideal.tdb'</span></em>, <em class="sig-param"><span class="n">tdb_phases</span><span class="o">=</span><span class="default_value">['FCC_A1', 'LIQUID']</span></em>, <em class="sig-param"><span class="n">tdb_components</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">temperature_type</span><span class="o">=</span><span class="default_value">'isothermal'</span></em>, <em class="sig-param"><span class="n">initial_temperature</span><span class="o">=</span><span class="default_value">1574</span></em>, <em class="sig-param"><span class="n">temperature_gradient</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cooling_rate</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">temperature_file_path</span><span class="o">=</span><span class="default_value">'T.xdmf'</span></em>, <em class="sig-param"><span class="n">initial_concentration_array</span><span class="o">=</span><span class="default_value">[0.40831]</span></em>, <em class="sig-param"><span class="n">cell_spacing</span><span class="o">=</span><span class="default_value">4.6e-06</span></em>, <em class="sig-param"><span class="n">d_ratio</span><span class="o">=</span><span class="default_value">1.0638297872340425</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">'explicit'</span></em>, <em class="sig-param"><span class="n">nbc</span><span class="o">=</span><span class="default_value">['periodic', 'periodic']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.init_NComponent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.init_tdb_parameters">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">init_tdb_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.init_tdb_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies the global vars which are parameters for the engine. Called from the function utils.preinitialize
Returns True if variables are loaded successfully, False if certain variables dont exist in the TDB
If false, preinitialize will print an error saying the TDB doesn’t have enough info to run the sim</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.make_seed">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">make_seed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">q1</span></em>, <em class="sig-param"><span class="n">q4</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">angle</span></em>, <em class="sig-param"><span class="n">seed_radius</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.make_seed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.npvalue">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">npvalue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">tdb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.npvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a numpy float from the sympy expression gotten from pycalphad
Reason: some numpy functions (i.e. sqrt) are incompatible with sympy floats!</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.quaternion_implicit_matrix">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">quaternion_implicit_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ac</span></em>, <em class="sig-param"><span class="n">ap</span></em>, <em class="sig-param"><span class="n">an</span></em>, <em class="sig-param"><span class="n">dc</span></em>, <em class="sig-param"><span class="n">dp</span></em>, <em class="sig-param"><span class="n">dn</span></em>, <em class="sig-param"><span class="n">adc</span></em>, <em class="sig-param"><span class="n">adp</span></em>, <em class="sig-param"><span class="n">adn</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.quaternion_implicit_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a quaternion implicit matrix
a = q1 central rows, d = q4 central rows, ad = off-center coupling rows
c = central value, p = positive neighbor, n = negative neighbor</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.quaternion_implicit_method">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">quaternion_implicit_method</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q1</span></em>, <em class="sig-param"><span class="n">q4</span></em>, <em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">HTp2</span></em>, <em class="sig-param"><span class="n">epsilon2</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">beta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.quaternion_implicit_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a quaternion implicit matrix, then applies it to q1 and q4 using the Peaceman-Rachford method</p>
<p>q1 and q4 are a and d</p>
<p>alpha is one of the primary parameters of the matrix: M*dt/(2dx^2)</p>
<p>D is the pseudo-diffusivity of the quaternion field, ${2HTp/ | nabla q | }$, recomputed after the half step. HTp2 is given numerator</p>
<p>beta is the cutoff parameter for gradq, values below beta will be clipped to equal beta</p>
<p>returns q1 and q4</p>
</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.NComponent.renormalize">
<code class="sig-prename descclassname">pyphasefield.Engines.NComponent.</code><code class="sig-name descname">renormalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q1</span></em>, <em class="sig-param"><span class="n">q4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.NComponent.renormalize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyphasefield.Engines.Template">
<span id="pyphasefield-engines-template-module"></span><h2>pyphasefield.Engines.Template module<a class="headerlink" href="#module-pyphasefield.Engines.Template" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyphasefield.Engines.Template.Template">
<em class="property">class </em><code class="sig-prename descclassname">pyphasefield.Engines.Template.</code><code class="sig-name descname">Template</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Template.Template" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyphasefield.html#pyphasefield.simulation.Simulation" title="pyphasefield.simulation.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyphasefield.simulation.Simulation</span></code></a></p>
<dl class="py method">
<dt id="pyphasefield.Engines.Template.Template.init_fields">
<code class="sig-name descname">init_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Template.Template.init_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.Template.Template.init_tdb_params">
<code class="sig-name descname">init_tdb_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Template.Template.init_tdb_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.Template.Template.initialize_fields_and_imported_data">
<code class="sig-name descname">initialize_fields_and_imported_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Template.Template.initialize_fields_and_imported_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.Template.Template.just_before_simulating">
<code class="sig-name descname">just_before_simulating</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Template.Template.just_before_simulating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.Template.Template.simulation_loop">
<code class="sig-name descname">simulation_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Template.Template.simulation_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyphasefield.Engines.Warren1995">
<span id="pyphasefield-engines-warren1995-module"></span><h2>pyphasefield.Engines.Warren1995 module<a class="headerlink" href="#module-pyphasefield.Engines.Warren1995" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyphasefield.Engines.Warren1995.Warren1995">
<em class="property">class </em><code class="sig-prename descclassname">pyphasefield.Engines.Warren1995.</code><code class="sig-name descname">Warren1995</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.Warren1995" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyphasefield.html#pyphasefield.simulation.Simulation" title="pyphasefield.simulation.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyphasefield.simulation.Simulation</span></code></a></p>
<dl class="py method">
<dt id="pyphasefield.Engines.Warren1995.Warren1995.init_fields">
<code class="sig-name descname">init_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.Warren1995.init_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.Warren1995.Warren1995.initialize_fields_and_imported_data">
<code class="sig-name descname">initialize_fields_and_imported_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.Warren1995.initialize_fields_and_imported_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.Warren1995.Warren1995.just_before_simulating">
<code class="sig-name descname">just_before_simulating</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.Warren1995.just_before_simulating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pyphasefield.Engines.Warren1995.Warren1995.simulation_loop">
<code class="sig-name descname">simulation_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.Warren1995.simulation_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Warren1995.engine_Warren1995">
<code class="sig-prename descclassname">pyphasefield.Engines.Warren1995.</code><code class="sig-name descname">engine_Warren1995</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.engine_Warren1995" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Warren1995.gradx">
<code class="sig-prename descclassname">pyphasefield.Engines.Warren1995.</code><code class="sig-name descname">gradx</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">dx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.gradx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Warren1995.gradxx">
<code class="sig-prename descclassname">pyphasefield.Engines.Warren1995.</code><code class="sig-name descname">gradxx</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">dx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.gradxx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Warren1995.grady">
<code class="sig-prename descclassname">pyphasefield.Engines.Warren1995.</code><code class="sig-name descname">grady</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">dx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.grady" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Warren1995.gradyy">
<code class="sig-prename descclassname">pyphasefield.Engines.Warren1995.</code><code class="sig-name descname">gradyy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phi</span></em>, <em class="sig-param"><span class="n">dx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.gradyy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyphasefield.Engines.Warren1995.init_Warren1995">
<code class="sig-prename descclassname">pyphasefield.Engines.Warren1995.</code><code class="sig-name descname">init_Warren1995</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sim</span></em>, <em class="sig-param"><span class="n">dim</span></em>, <em class="sig-param"><span class="n">diamond_size</span><span class="o">=</span><span class="default_value">15</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyphasefield.Engines.Warren1995.init_Warren1995" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyphasefield.Engines">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pyphasefield.Engines" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pyphasefield</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, pyphasefield Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/source/pyphasefield.Engines.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>